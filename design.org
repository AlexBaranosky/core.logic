* Logos Design Notes
** Rest LVars
*** They pollute the unify logic too much.
    We have to peek into collections to see if they contain LVars
    during unification. This requires us to add some wacky
    conditional logic to unify* as well as reify-lookup
*** Consider providing a LCons
    It would pretty much look like Pair. It would allow us to do
    something like the following:

    (== (lcons a lvar) '(a))

    (== (a . lvar) '(a))

    We can then check if we are looking at LCons in unify.

    If we are in-lseq and we encounter an lvar, we unify with nil.
    
    (== (lvar) nil)

    won't unify since, (lvar) is a sequence and nil is not
*** Repercussions for convenient ?&r syntax for unifier

    (unifier' '(?x ?&r) '(1 2 3 4))

    This maybe the only legitimate case for rest vars. They're just
    a marker to trigger unifying the rest of the other side.
*** How would conj-o work?

    (conj-o d a r)

    We would like conj-o to *infer* the type from r if provided.

    (conj-o d 'x ['x])
    (== (conj d 'x) ['x])

    But we have a general problem with primitive operators, since they
    can't take a LVar.

    What if we use LCons here ? LCons type is weak, always unify to
    the type that isn't an LCons ?
** LCons
*** Trying to overload cons seems like a bad idea
    Need to implement key interface and this requires a deeper
    knowledge of the relationships between various fns and
    datastructures than I currently have. The problem is the Cons
    expects something that really is a Seq not just just something
    that pretends to be one.
*** We now have something that be treatd as an ISeq or IPair
    traversing it does require one more check?

    (nseq? (LCons. 'a (lvar 'x))) ; false
    (seq? (LCons. 'a (LCons 'b (lvar 'x)))) ; true
    (seq? (rhs (LCons. 'a (lvar 'x)))) ; false
*** Now need to understand the performance implications
    Looking at PersistentList, equality between two list is
    linear in their legnth
    Looking at PersistentVector, equality between two small
    vectors is slower than two small PersistentLists
*** implement printing    
*** implement equiv
    should see how persistent lists do it.
*** implement equals
*** implement hashCode
*** Implications of LCons
    (== (lcons 'a (lvar 'd)) '(a d))
    Unification, the above should unify the lvar to '(d) EASY

    (== (lcons 'a (lvar 'd)) (lvar 'q)))
    Reification, 'q no holds (lcons 'a ?d)
    
    (== ?x (lcons ?y ?z))
    (== ?y 'a)
    (== ?z '(1 2))
    
    (reify s ?x)
    
    ?x now holds (lcons 'a '(1 2))

    but now it is a proper seq!, unification prevents proper
    lcons from leaking out!

    AHA!
    
    if the right hand side is an lcons, we lcons
    lcons already does the right thing! normal cons if the
    right hand side is a propery seq!
