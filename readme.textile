h1. Logos

A Logic Programming library for Clojure. At its heart is an implementation of miniKanren as described in William Byrd's dissertation "Relational Programming in miniKanren: Techniques, Applications, and Implementations":http://gradworks.umi.com/33/80/3380156.html. It's also described in great detail in the "The Reasoned Schemer":http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=10663.

h2. About

This library is under heavy development as I cover the ideas in Byrd's thesis and other sources on logic programming. It currently only supports the Clojure 1.3.0 alphas.

There are most certainly bugs. I hope to iron out a solid core version with numerous tests before working on alternate implementations (which will most likely be done in branches).

This is not the first implementation of miniKanren in Clojure. Jim Duey's version can be found "here":https://github.com/jduey/mini-kanren. His work on that got me interested in logic programming in the first place.

h2. YourKit

YourKit has has given me a free license for their profiler, greatly simplifying the profiling of Logos performance. 

YourKit is kindly supporting open source projects with its full-featured Java Profiler.
YourKit, LLC is the creator of innovative and intelligent tools for profiling
Java and .NET applications. Take a look at YourKit's leading software products:
<a href="http://www.yourkit.com/java/profiler/index.jsp">YourKit Java Profiler</a> and
<a href="http://www.yourkit.com/.net/profiler/index.jsp">YourKit .NET Profiler</a>.

h2. Notes

I stayed pretty true to the structure of the original implementation. However there's some originality to the substitutions implementation and most of the non-trivial core functions have been significantly changed to deal with the fact that Clojure uses a variety of data structures (instead of just lists) to represent source. Also Clojure's cons operator differs significantly from Scheme's so I added the <code>LConsSeq</code> protocol. All iterable Clojure data structures are extended to this protocol. Sequences which end in a logic variables can be represented by using <code>lcons</code>

<pre>
(lcons 'a (lvar 'b)) ; (a . <lvar:b>)
</pre>

Logic variables are istances of <code>lvarT</code> not vectors as they are in Scheme.

The goal and goal constructor portion of the original implementation has been adapted to protocols (<code>IBind</code>, <code>IMPlus</code>) and deftypes (<code>MZero</code>, <code>Unit</code>, <code>Inc</code>, <code>Choice</code>). <code>take</code> has been changed to return a Clojure vector of answers.

Currently the <code>Substitutions</code> defrecord uses <code>clojure.lang.PersistentHashMap</code> internally. This will probably be replaced with something more suitable for triangular substitutions. I'll be investigating Skew Binary Random Access Lists as well as Finger Trees (Okasaki).

h2. Goals

* Simplicity. Optimizations should not destroy the *ideas* behind the original design. Any person willing to take take the time to understand the original Scheme implementation should have little trouble understanding how Logos is put together.
* Performance. I've made sure that this version is competitive with miniKanren running under Racket. A long term goal is to have Logos perform well enough that a predicate dispatch system could be built on top of it. 
* Emphasis on pure relational programming.
* Parallel logic programming.
* Original implementation. This will take some time as I acquire a deeper understanding of miniKanren and dive into the vast literature on logic programming.

h2. Contributing

I will only take contributions from people who have submitted Clojure CAs.

h2. Examples

<pre>
(run* [q]
  (rest-o q [1 2])) ; [(_.0 1 2)]
</pre>

<pre>
(run 5 [x]
  (exist [y]
    (append-o (llist 'cake y) '(d t) x)))

;; [(cake _.0 d t)
;;  (cake _.0 _.1 d t)
;;  (cake _.0 _.1 _.2 d t)
;;  (cake _.0 _.1 _.2 _.3 d t)
;;  (cake _.0 _.1 _.2 _.3 _.4 d t)]
</pre>

<pre>
(defn likes [x y]
  (cond-e
   ((== x 'john) (== y 'mary))
   ((== x 'mary) (== y 'john))))

(defn musician [x]
  (cond-e
   ((== x 'john))
   ((== x 'bob))))

(run* [q]
  (likes q 'mary)
  (musician q)) ;; [john]

(run* [q]
  (musician q)) ;; [john bob]

(run* [q]
  (exist [x y]
    (likes x y)
    (== [x y] q))) ;; [[john mary] [mary john]]
</pre>

<pre>
(unifier' '(?x ?y ?z) '(1 2 ?y)) ; (1 2 _.0)
</pre>

The above is quite slow since we have to walk the data structure and replace the logic var symbols. It's more efficient to <code>prep</code> the expressions before hand if you're going to be unifying the same expressions over and over again.

<pre>
(let [[u w] (map prep ['(?x ?y) (1 2)])]
  (unifier u w))
</pre>

h2. Resources

* "Relational Programming in miniKanren: Techniques, Applications, and Implementations":http://gradworks.umi.com/33/80/3380156.html
* "The Reasoned Schemer":http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=10663
* "Efficient representations for triangular substitutions: A comparison in miniKanren":https://www.cs.indiana.edu/~lkuper/papers/walk.pdf
* "A pattern matcher for miniKanren, or, how to get into trouble with CPS macros":http://www.cs.indiana.edu/~lkuper/papers/lambdae.pdf
* "Kanren":http://kanren.sourceforge.net/
* "Logical JVM: Implementing the miniKanren logic system in Scala":http://hircus.multics.org/kanren/presentation.html
* "minikanren-scala":https://github.com/hircus/minikanren-scala
* "Purely Functional Data Strucutres":http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.3080&rep=rep1&type=pdf